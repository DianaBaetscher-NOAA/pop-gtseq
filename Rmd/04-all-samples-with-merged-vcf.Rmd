---
title: "04-all-samples-with-merged-vcf"
author: "Diana Baetscher"
date: "2023-07-07"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The data included here consists of 7 MiSeq runs, for which samples were re-numbered, VCF files merged, and genotypes called using the "all_pop.vcf" file in microhaplot.
UPDATE: the all_pop.vcf file was missing variants from some of the individual MiSeq runs and so I remade the merged VCF file. The new version is called "pop02_03_04_05_06_merged.vcf."


We need to test the baseline for assignment using these haplotypes and then 


Using the rds file output from microhaplot:
1. read in rds files
2. apply read depth filters
3. apply allele balance filter

Then,
4. add metadata (ABLG number)
5. check for duplicate samples 
6. check for duplicate genotypes


To save some bandwidth, I cycled over the individual rds files and merged them with their ABLG numbers in `04.0-read-in-rds-files.Rmd` and will read in that dataframe here.

```{r load-libs-and-funcs}
library(tidyverse)
library(readxl)
library(stringr)
library(lubridate)
library(adegenet)
# map packages
library(ggplot2)
library(sf)  
library(rnaturalearth)
library(rnaturalearthdata)


source("../R/microhaplot-genos-funcs.R")
source("../R/pca-funcs.R")
```


```{r read-in-genos-loop}
#### Call genos from the microhaplot rds files ####

# this next step uses a little data frame that has the names and GTSeq run numbers
# I got that file like this:
# dsb:rds_files dianabaetscher$ pwd
# /Users/dianabaetscher/Desktop/NOAA_grad/git-repos/rockfish-species-id/new_baseline_data/feather_files
# dsb:feather_files dianabaetscher$ ls -l | awk 'BEGIN {print "gtseq_run", "file"} NR >1 && !/posinfo/ {num = $NF; gsub(/gtseq/, "", num); gsub(/[._].*$/, "", num);  print num, $NF}' > ../rds-file-list.txt 


# get the names of the files
# fdf <- read.table("../data/merged-rds-file-list.txt", stringsAsFactors = FALSE, header = TRUE) %>%
#   tbl_df()
# dir <- "../data/rds_files/rds_files_new"
# 
# 
# # cycle over them, read them and add the gtseq_run column on each.
# # at the end, bind them together.
# genos_long <- lapply(1:nrow(fdf), function(i) {
#   message("Working on ", fdf$file[i])
#   call_genos_from_haplotRDS(path = file.path(dir, fdf$file[i])) %>%
#     mutate(gtseq_run = fdf$gtseq_run[i]) %>%
#     select(gtseq_run, everything())
# }) %>%
#   bind_rows()
# 
# # we go ahead and save it in data/processed, with xz compression
# saveRDS(genos_long, file = "../data/processed/called_genos.rds", compress = "xz")
# 
# 
# #### In the end, let us get a data frame that includes genotypes for all the individuals  ####
# # and which explicitly has NAs in places where data are missing, and also 
# # has the NMFS_DNA_ID on there
# genos_long_explicit_NAs <- genos_long %>%
#   select(gtseq_run, id) %>%
#   unique() %>%
#   unite(col = gid, sep = "_", gtseq_run, id) %>%
#   select(gid) %>%
#   unlist() %>%
#   unname() %>%
#   expand.grid(gid = ., locus = unique(genos_long$locus), gene_copy = 1:2, stringsAsFactors = FALSE) %>%
#   tbl_df() %>% 
#   separate(gid, into = c("gtseq_run", "id"), convert = TRUE) %>%
#   left_join(., genos_long) %>%
#   arrange(gtseq_run, id, locus, gene_copy)
# 
# # and then save that
# saveRDS(genos_long_explicit_NAs, file = "../data/processed/called_genos_na_explicit.rds", compress = "xz")
  
```

### Add samplesheet/metadata/ABLG numbers

Get the samplesheet info:
```{r organize-samplesheets}
# samplesheet info for all seven plates
# list of files in samplesheets directory

ss_data_all <- list.files(path = "../data/samplesheets/",  # Identify all CSV files
                       pattern = "*.csv", full.names = TRUE) %>% 
  lapply(read_csv, skip = 19) %>%                              # Store all files in list
  bind_rows                                         # Combine data sets into one data set 

# remove the non-POP data from samplesheets
pop_ss <- ss_data_all %>%
  filter(Sample_Project %in% c("POP", "POPMix")) %>%
  mutate(Sample_ID = str_replace(Sample_ID, "ABLG", "")) # make the ABLG number consistently formatted

```

Take a quick look at the metadata:
Avoid importing the full metadata unless something changes - this takes a while and throws a bunch of warnings.
```{r full-metadata-import}
# meta data exported from the database
# meta <- read_xlsx("../data/samples/POP_database_export_May2023.xlsx", sheet = "Sheet1")
# 
# rockfish_meta <- meta %>%
#   filter(SpeciesName == "Sebastes alutus" | Family == "Sebastidae" | Genus == "Sebastes" | str_detect(CommonName, "rockfish"))
# 
# # narrow that down to just rockfish
# pop <- meta %>%
#   filter(SpeciesName == "Sebastes alutus")
# #the ABLG number is currently numeric - fix that
# rockfish_meta$ABLG <- as.character(rockfish_meta$ABLG)

# fix some issues
# rockfish_meta %>%
#   mutate(DonatingLab = ifelse(DonatingLab %in% c("Gharrett", "Tony Gharret"), "Tony Gharrett", DonatingLab)) %>%
#   write_csv("../data/rockfish_metadata.csv")

```




```{r organize-metadata}
pop <- read_csv("../data/rockfish_metadata.csv")

pop_ss$Sample_ID <- as.numeric(pop_ss$Sample_ID)
# combine samplesheet and metadata info
POP_meta_ss <- pop_ss %>%
  left_join(., pop, by = c("Sample_ID" = "ABLG")) %>%
  select(Sample_ID, Sample_Plate, id, gtseq_run, SpeciesName, StartLatitudeDD, StartLongitudeDD, EndLatitudeDD, EndLongitudeDD, CruiseID, HaulID, StationID, DepthM, LengthMM, DonatingLab, CollectionYear, CollectionMonth, CollectionDay) %>%
  mutate(CruiseID = str_replace(CruiseID, "-", ""))

# formats
POP_meta_ss$CruiseID <- as.numeric(POP_meta_ss$CruiseID)
POP_meta_ss$CollectionYear <- as.numeric(POP_meta_ss$CollectionYear)
POP_meta_ss$CollectionMonth <- as.numeric(POP_meta_ss$CollectionMonth)
POP_meta_ss$HaulID <- as.numeric(POP_meta_ss$HaulID)

# now add the ABLG number onto the genos dataframe
# genos_ablg <- POP_meta_ss %>%
#   select(Sample_ID, id, gtseq_run) %>%
#   left_join(., genos_long_explicit_NAs) %>%
#   rename(ABLG = Sample_ID)

# quick question:
# do we have genotypes for samples with no metadata?
# tmp1 <- POP_meta_ss %>%
#   select(Sample_ID, id, gtseq_run)
# 
# genos_long_explicit_NAs %>%
#   anti_join(., tmp1)
# 
# 
# genos_ablg %>%
#   write_rds("../data/processed/genos_ablg.rds")

```



```{r read-in-genos}
genos_ablg <- read_rds("../data/processed/genos_ablg.rds") %>%
  filter(!str_detect(ABLG, "NTC"))
# make numeric to match the Sample_ID
genos_ablg$ABLG <- as.numeric(genos_ablg$ABLG)
```


```{r remove-non-POP-species}
just_pop_meta <- POP_meta_ss %>%
  filter(SpeciesName == "Sebastes alutus") %>%
  select(Sample_ID) %>%
  unique()

genos_just_pop <- genos_ablg %>%
  inner_join(., just_pop_meta, by = c("ABLG" = "Sample_ID"))

```
2,114 samples



### Check for duplicated samples

Ok, so the first time through, I implemented this as we had before; taking the highest read depth genotype per locus for each multiply-genotyped ABLG number. However, the genotype patterns look messy and I'm beginning to suspect that the ABLG numbers associated with some of the samples might not be accurate. So, to avoid interleaving genotypes that do not actually belong to the same individual, let's just remove one of each duplicate pair based on missing data.


## Some initial filters

### Take highest read-depth call for multiply-genotyped DNA_IDs


If an individual is multiply-genotyped, take the
genotype with the highest total read depth.  
```{r take-just-one}
# slow-ish function to get the total read depth column
tdepth <- function(a, d) {
  if(any(is.na(a))) {
    return(NA)
  }
  if(a[1]==a[2]) {
    return(d[1])
  } else {
    return(d[1] + d[2])
  }
  
}
# this takes the highest read-depth instance of each duplicately-genotyped individual.
geno_one_tmp <- genos_just_pop %>%
  group_by(ABLG, locus, gtseq_run) %>% # this assumes the same sample should not be on the same sequencing run.
  mutate(total_depth = tdepth(allele, depth)) %>%
  ungroup() 

duplicates <- geno_one_tmp %>%
  select(ABLG, gtseq_run) %>%
  unique() %>%
  group_by(ABLG) %>%
  tally() %>%
  filter(n > 1) %>%
  select(-n)

duplicates %>%
  left_join(., geno_one_tmp) %>%
  group_by(ABLG, gtseq_run) %>%
  mutate(missing_data = ifelse(is.na(depth), 1, 0)) %>%
  summarise(miss_loci = sum(missing_data)) %>%
  pivot_wider(names_from = gtseq_run, values_from = miss_loci)
  # in nearly every situation, the gtseq run from 0308 has less missing data. Let's go with that.
  
dups_to_remove <- duplicates %>%
   left_join(., geno_one_tmp) %>%
    filter(gtseq_run == "201")

geno_one_each <- geno_one_tmp %>%
  anti_join(., dups_to_remove)

  
# %>%
#   arrange(ABLG, locus, total_depth, gtseq_run, depth) %>%
#   group_by(ABLG, locus) %>%
#   mutate(rank = 1:n()) %>% 
#   filter(rank <= 2) %>%
#   ungroup()
  

# how many samples now?
geno_one_each %>%
  group_by(ABLG) %>%
  tally() %>%
  arrange(desc(n)) 

```
2,114 unique ABLG numbers (samples).

(24 samples duplicately genotyped).



### Remove missing data and then check for duplicate genotypes

#### Locus evaluation

How many loci and how many alleles?

```{r}
loc_list <- geno_one_each %>%
  group_by(locus) %>%
  filter(!is.na(allele.balance)) %>%
  summarise(loc_depth = sum(depth)) %>%
  arrange(desc(loc_depth)) %>%
  select(locus)

loc_list
```
167 loci



```{r}
# alleles
geno_one_each %>%
  filter(!is.na(allele)) %>%
  select(locus, allele) %>%
  unique() %>%
  group_by(locus) %>%
  tally() %>%
  arrange(desc(n))

# loci
locs_to_toss_first <- geno_one_each %>%
  filter(!is.na(allele)) %>%
  select(locus, allele) %>%
  unique() %>%
  group_by(locus) %>%
  tally() %>%
  arrange(desc(n)) %>%
  filter(n < 2 | n > 40)

  
```
742 alleles across 167 loci with between 1-46 alleles per locus. Clearly the 46 needs to be removed!!

5 of the loci are monomorphic.


```{r toss-the-monomorphic-loci}
# get rid of those now
# plus the one with 54 alleles
genos_no_monomorphic <- geno_one_each %>%
  anti_join(., locs_to_toss_first)

```
Take a look at the overall dataset.

What about the average depth across loci?

```{r plot-depth-per-locus}
genos_no_monomorphic %>%
  group_by(locus) %>%
  mutate(avg_depth = mean(depth, na.rm = TRUE)) %>%
  ggplot(aes(x = reorder(locus, avg_depth), y = reorder(ABLG, depth), fill = log(depth))) +
  geom_tile()

```
Missing data:

```{r}
# missing data across loci
locs_to_toss <- genos_no_monomorphic %>%
  group_by(locus) %>%
  mutate(missingness = ifelse(is.na(allele), 1, 0)) %>%
  summarise(sum(missingness)) %>% 
  filter(`sum(missingness)`>2280) %>% # more than 50% missing data (two alleles per locus)
  select(locus) # drop those loci for now and see how the assignment goes

# just the keepers
genos_locs_filtered <- genos_no_monomorphic %>%
  anti_join(., locs_to_toss)

```
26 loci with >50% missing data***

***at some point, it would be interesting to return to this if the B4 population has higher rates of missing data (because of divergence).


The patterns of missing data across loci are generally weird. Maybe more indicative of species-specific patterns?

```{r}
# summary of remaining loci
genos_locs_filtered %>%
  filter(!is.na(allele)) %>%
  select(locus, allele) %>%
  unique()

genos_locs_filtered %>%
  filter(!is.na(allele)) %>%
  select(locus, allele) %>%
  unique() %>%
  group_by(locus) %>%
  tally() %>%
  arrange(desc(n))

```
136 loci, 605 alleles
```{r}
genos_locs_filtered %>%
  filter(!is.na(allele)) %>%
  select(locus, allele) %>%
  unique() %>%
  group_by(locus) %>%
  tally() %>%
  summarise(median(n))
```



```{r}
# QC check
genos_locs_filtered_just_one <- genos_locs_filtered %>%
  # group_by(ABLG, locus) %>% # there should be no more than 2 alleles for a given indiv/locus
  # tally() %>%
  # filter(n > 2) %>%
  # left_join(., genos_locs_filtered) %>%
  group_by(ABLG, id, gtseq_run, gene_copy, depth) %>%
  unique()
  

# I fixed the issue earlier, but this is a good back-up verification
genos_locs_filtered_just_one %>%
  group_by(ABLG, locus) %>%
  tally() %>%
  filter(n > 2)
  
```

## Missing data in individuals

Total number of loci = 136 Total number of gene copies = 272

```{r}
# 30% missing data
272*0.3

inds_to_toss <- genos_locs_filtered_just_one %>%
  group_by(ABLG) %>%
  mutate(missingness = ifelse(is.na(allele), 1, 0)) %>%
  summarise(sum(missingness)) %>%
  arrange(desc(`sum(missingness)`)) %>%
  filter(`sum(missingness)` > 82) # remove samples with >25% missing data

# just the keepers
genos_locs_ind_filtered <- genos_locs_filtered_just_one %>%
  anti_join(., inds_to_toss) %>%
  ungroup()


```
So many individuals dropped out completely! 661 of them! And what's weird is that a LOT have total missing data. Hundreds are missing all data. Wrong species?? Poor quality?


```{r add-meta-data-to-missing-data}
inds_missing_data_meta <- inds_to_toss %>%
  left_join(., POP_meta_ss, by = c("ABLG" = "Sample_ID")) 
  
```


Take a closer look:
```{r missing-data-by-sample}
genos_locs_filtered_just_one %>%
  group_by(ABLG) %>%
  mutate(missingness = ifelse(is.na(allele), 1, 0)) %>%
  summarise(missing_data = sum(missingness)) %>%
  ggplot(aes(x = missing_data)) +
  geom_histogram()

```

How many indivs retained?

```{r inds-retained}
genos_locs_ind_filtered %>%
  select(ABLG) %>%
  unique()

```
1,453 individuals retained.

Take a look at that dataset

```{r plot-cleaned-genos}
genos_locs_ind_filtered  %>%
  ggplot(aes(x = reorder(locus, depth), y = reorder(ABLG, depth), fill = log10(depth))) +
  geom_tile()

```


## Map sample locations

Make a quick map of the sample locations for reference/context while thinking about baseline data.
```{r mapping-code}
world <- ne_countries(scale = "medium", returnclass = "sf")

goa_map <- ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-179, -120), 
           ylim = c(62, 30), 
           expand = FALSE) +
  theme_bw()

goa_map +
  geom_jitter(data = POP_meta_ss, aes(x = StartLongitudeDD,y = StartLatitudeDD), size = 1, alpha = 0.3, height = 0.2, width = 0.2, color = "dodgerblue") +
  labs(x = "Longitude",
       y = "Latitude",
       title = "Sebastes alutus GTseq sampling distribution") +
  theme(
    legend.text = element_text(face = "italic"),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
  ) #+
 #  scale_y_continuous(breaks = c(56, 58, 60, 62)) +
 #  scale_x_continuous(breaks = c(-155, -145)) +
 #  guides(color = guide_legend(
 #    override.aes = list(alpha = 1, size = 3), 
 #    label.theme = element_text(size = 12, face = "italic"),
 #    title.theme = element_text(size = 14)))

```

What are the baseline samples in this case?

There are two ways to analyze these data:
1) identifying groups (PCA) without regard to baseline samples/assignment
2) using the baseline samples for which we have lcWGS data to then do assignment of the rest of the samples.



# Taking data through to a PCA


The format I need for the PCA is strata, indiv, markers, genotype (allele idx)

```{r format-alleles-for-PCA}
# first make integers of the alleles
alle_idxs <- genos_locs_ind_filtered %>% 
  #unite(gtseq_run, id, col = "sample", remove = F) %>%
  dplyr::select(ABLG, locus, gene_copy, allele) %>%
  group_by(locus) %>%
  mutate(alleidx = as.integer(factor(allele, levels = unique(allele)))) %>%
  ungroup() %>%
  arrange(ABLG, locus, alleidx) # rubias can handle NA's, so no need to change them to 0's

# Make the df match the requirements for tidy_genomic_data

long_df <- alle_idxs %>%
  select(-allele, -gene_copy) %>%
  mutate(group = "POP") %>%
  #left_join(., spp_indiv) %>%
  #select(species, everything()) %>%
  rename(INDIVIDUALS = ABLG, STRATA = group, MARKERS = locus, GT = alleidx) %>%
  filter(!str_detect(INDIVIDUALS, "NTC")) # Remove NTCs at this point because they are missing nearly all markers.

```




Read in some metadata to take a closer look at those samples/assignments.

```{r known-pop-groups}
# read in metadata for POP gtseq3 run with group designations
# these 335 individuals are those retained from the lcWGS dataset after filtering
pops_known <- read_csv("../data/pop_335_population_assignment.csv") %>%
  mutate(ABLG = str_replace(ABLG, "ABLG", "")) 

pops_known$ABLG <- as.numeric(pops_known$ABLG)

pops_known1 <- pops_known %>% # fix the syntax for matching up with the database/metadata 
  left_join(., POP_meta_ss, by = c("ABLG" = "Sample_ID")) %>% # add samplesheet/metadata info
  rename(INDIVIDUALS = ABLG)

# just the group assignments
pop_grps <- pops_known1 %>%
  select(INDIVIDUALS, pop_assign) %>%
  rename(grp = pop_assign) %>%
  filter(INDIVIDUALS != "NA_NA")

# and get some genotype info on there
long_df_w_grps <- long_df %>%
  left_join(., pop_grps) %>%
  mutate(STRATA = ifelse(!is.na(grp), grp, STRATA)) %>%
  select(-grp)

# how many per group?
long_df_w_grps %>%
  select(INDIVIDUALS, STRATA) %>%
  unique() %>%
  group_by(STRATA) %>%
  tally()

```

```{r all-samples-pca}
# reformat genotypes for genind conversion
# create 3 digit integers from the genotypes
long_df$GT3 <- Format(long_df$GT, ldigits = 3, digits = 0)
      
# fix NAs
long_df0s <- long_df %>%
  mutate(GT3 = ifelse(is.na(GT3), "000", GT3))
      
# Now combine the GT3 column per indiv/marker:
# make the genos characters and then try pasting them as strings
long_df0s$GT3 <- as.character(long_df0s$GT3)
      
long_df3digit <- long_df0s %>%
  group_by(INDIVIDUALS, MARKERS) %>% 
  arrange(GT3, .by_group = TRUE) %>% 
  summarise(GENOTYPE = toString(GT3)) %>%
  ungroup()
      
# paste strings together
long_df3digit$GENOTYPE <- gsub(", ","",long_df3digit$GENOTYPE)
      
# add back on species identity as strata
df_for_conversion <- long_df0s %>% 
  select(-GT, -GT3, -MARKERS) %>%
  unique() %>%
  left_join(., long_df3digit) %>%
  rename(GT = GENOTYPE) %>%
  mutate(GT = ifelse(GT == "000000", NA, GT))
      
df_for_conversion$STRATA <- as.factor(df_for_conversion$STRATA)
      
# use the radiator package for this conversion
pop_genind_df <- write_genind(df_for_conversion)
   
# Now that the data is a genind object, we can do all sorts of things using the adegenet package.
# Allele presence absence data are extracted and NAs replaced using tab:
pop_dataset <- tab(pop_genind_df) # double check that is this the appropriate method: options are "as is", "mean", or "zero"
# frequency - should the data be transformed to relative frequencies
      
# PCA
dataset_pop1 <- dudi.pca(pop_dataset, nf = 6, scannf = F, center = T) # I lowered this based on the screeplot

pop_pca_df <- rownames_to_column(dataset_pop1$li, var = "indiv")

as_tibble(pop_genind_df@strata) %>%
  left_join(., pop_pca_df, by = c("INDIVIDUALS" = "indiv")) %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis1, y = Axis2, label = INDIVIDUALS)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_text(nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq all samples",
       x = "PC1",
       y = "PC2")

```


## just the POP groups from the 335 samples

```{r just-baseline-samples}
baseline <- long_df_w_grps %>%
  filter(STRATA != "POP")

# that function worked.
#convert_to_genind_pca(long_df_w_grps, "mixture_plus_baseline")

# and remove the identity of the groups to just visualize the clusters
# baseline_test <- baseline %>%
#   mutate(STRATA = "pop")
#
#
# convert_to_genind_pca(baseline_test, "Baseline_no_groups")
```
It seems like C might be admixed between A and D, which is why there are samples that were assigned to the A and D clusters in the lcWGS data now in C. Admixture analysis would tell us more. Harder to say what's going on with the B clusters.

Go sleuthing a bit more on the baseline question and missing data issues.

```{r explore-missing-data-w-metadata-context}
# summarize the missing data per individual
# then add metadata
missing_w_meta <- genos_locs_filtered %>%
  group_by(gtseq_run, id) %>%
  mutate(missingness = ifelse(is.na(allele), 1, 0)) %>%
  summarise(missing_data = sum(missingness)) %>%
  left_join(., POP_meta_ss) 
#   
# goa_map +
#   geom_jitter(data = missing_w_meta, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = missing_data), size = 1, alpha = 0.3, height = 0.2, width = 0.2) +
#   labs(x = "Longitude",
#        y = "Latitude",
#        title = "Sebastes alutus GTseq missing data") 
# 
# toss_ind <- missing_w_meta %>%
#   filter(missing_data > 200)
# 
# goa_map +
#   geom_jitter(data = toss_ind, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = missing_data), size = 1, alpha = 0.3, height = 0.2, width = 0.2) +
#   labs(x = "Longitude",
#        y = "Latitude",
#        title = "Sebastes alutus GTseq missing data") 
# 
# 
# # What about the keepers
# keep_ind <- missing_w_meta %>%
#   filter(missing_data < 77)
# 
# goa_map +
#   geom_jitter(data = keep_ind, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = missing_data), size = 1, alpha = 0.3, height = 0.2, width = 0.2) +
#   labs(x = "Longitude",
#        y = "Latitude",
#        title = "Sebastes alutus GTseq missing data") 
```


Ok, so it's a little light on the southern samples, but they're included.

Can I put the strata info for the baseline samples on the map?

```{r map-group-distributions-from-metadata}
grps_for_map <- missing_w_meta %>%
  left_join(., pop_grps, by = c("Sample_ID" = "INDIVIDUALS")) %>%
  filter(!is.na(grp)) %>%
  filter(grp != "B") %>%
  filter(LengthMM > 220 | is.na(LengthMM) | LengthMM == 0) # just adults. accommodating current issues with the metadata database.
  

goa_map +
  geom_jitter(data = grps_for_map, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = grp), size = 2, alpha = 0.7, height = 0.2, width = 0.2) +
  facet_wrap(~grp) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "Sebastes alutus baseline group assignments from lcWGS") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange","firebrick", "purple4")) +
  theme(
    axis.text = element_text(size = 8),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )

ggsave("pdf_outputs/POP_baseline_group_distribution_panels.pdf", width = 10, height = 7)
```

Some notes:
B4 appears exclusively SE of Yakutat, and is the only group found in the lower 48 with the exception of one B2 sample in Northern CA.
B1 is distributed throughout the central GOA.

Laura mentioned that at the time the GTseq panel was developed, the four separate B groups were not clear and so were not targeted for differentiation using these markers.


Looking back at Laura's slides covering the WGS dataset, not all of the individuals were adults...

```{r small-sizes}
# we know that juveniles might be distributed differently
# small_fish <- grps_for_map %>%
#   left_join(., meta) %>%
#   filter(LengthMM != 0 & LengthMM < 200)
# 
# 
# tmp <- grps_for_map %>%
#   anti_join(., small_fish)
# 
# # just adults
# goa_map +
#   geom_jitter(data = tmp, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = grp), size = 1, alpha = 0.7, height = 0.2, width = 0.2) +
#   facet_wrap(~grp) +
#   labs(x = "Longitude",
#        y = "Latitude",
#        title = "Sebastes alutus baseline group assignments from lcWGS (adults)") +
#   scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange","firebrick", "purple4")) +
#   theme(
#     axis.text = element_text(size = 8),
#     axis.title.x = element_text(margin = margin(t = 10)),
#     axis.title.y = element_text(margin = margin(r = 10))
#   )
# 
# 
# ggsave("pdf_outputs/POP_adult_baseline_group_distribution_panels.pdf", width = 10, height = 7)
```
A, D, and B are very different. C is somewhat intermediate to A and D.
All groups co-occur in the central GOA.


Removing the small fish from the PCAs too:
```{r}
# big_fish <- pop_groups %>%
#   inner_join(., tmp)
#   
# convert_to_genind_pca(big_fish, "Baseline_groups_adults")

```


Metadata for POP baseline?
```{r metadata-for-pop-baseline}
meta_for_strata <- POP_meta_ss %>%
  unite(gtseq_run, id, col = "INDIVIDUALS")

baseline_meta <- grps_for_map %>%
   left_join(., meta_for_strata)
  
# baseline_meta %>%
#   filter(DonatingLab == "Jacek Maselko") %>%
#   filter(CruiseID == "201901")

```



Read in the YOY IDs that were used to define group membership for the lcWGS data (according to Laura Timm).

```{r original-groups-from-yoys}
yoy <- read_xlsx("../data/Jacek_YOY_for_lcWGS_define_groups.xlsx") %>%
  mutate(ABLG = str_replace(ABLG, "ABLG", ""))

yoy$ABLG <- as.numeric(yoy$ABLG)

YOY_baseline <- yoy %>%
  left_join(., baseline_meta, by = c("ABLG" = "Sample_ID")) %>%
  select(ABLG, pop_assign, grp) %>%
  left_join(long_df_w_grps, by = c("ABLG" = "INDIVIDUALS")) %>%
  rename(INDIVIDUALS = ABLG) %>%
  select(INDIVIDUALS, MARKERS, GT, pop_assign) %>%
  rename(STRATA = pop_assign)
```

Compare depth distributions for samples in groups A and D:

How many total samples per group?
```{r non-YOY-samples-per-group}
baseline_meta %>%
  anti_join(., YOY_baseline, by = c("Sample_ID" = "INDIVIDUALS")) %>%
  group_by(grp) %>%
  mutate(B = ifelse(grp %in% c("B1", "B2", "B3", "B4"), "B groups", "A, C, D groups")) %>%
  filter(!is.na(DepthM)) %>%
  filter(DepthM != 0) %>%
  filter(grp != "B") %>% # too few samples
    filter(LengthMM > 220) %>%
  tally() 

```
Groups A and D are essentially non-overlapping in depth, with A being deeper and D shallower.

NOTE: based on Love et al. remove all <220 mm because that's < 50% maturity (juveniles behave differently)
I'm also now curious about whether the size distributions for the different groups are different (i.e., do we catch more B2 indivs as juveniles?)

Kind of amazing to see the potential depth segregation. Take a closer look at A,C,D separate from Bs:

```{r depth-distribution-by-group}
p <- baseline_meta %>%
  anti_join(., YOY_baseline, by = c("Sample_ID" = "INDIVIDUALS")) %>%
  group_by(grp) %>%
  mutate(B = ifelse(grp %in% c("B1", "B2", "B3", "B4"), "B groups", "A, C, D groups")) %>%
  filter(!is.na(DepthM)) %>%
  filter(DepthM != 0) %>%
  filter(grp != "B") %>% # too few samples
    filter(LengthMM > 220) %>% # this is the 50% age at maturity, according to Love et al.
  ggplot(aes(x = grp, y = DepthM, color = grp)) +
  geom_violin() +
  facet_grid(cols = vars(B), scales = "free") +
  theme_bw() +
  labs(x = "Sebastes alutus, genetic group",
       y = "Depth (m)",
       title = "Sebastes alutus, collection depth by genetic group") +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  ) +
    scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "firebrick", "darkorange"))

# violin plot with dot plot
p + geom_boxplot(width=0.1, color = "black") +
  geom_jitter(shape=16, position=position_jitter(0.1), alpha = 0.6)

ggsave("pdf_outputs/pop_grp_depth_dist.pdf")

```
The deepest samples are from Jacek's 2019 collections.


### Size distributions

```{r plot-size-distributions-by-group}
l <- baseline_meta %>%
  #anti_join(., YOY_baseline) %>%
  group_by(grp) %>%
  mutate(B = ifelse(grp %in% c("B1", "B2", "B3", "B4"), "B groups", "A, C, D groups")) %>%
  filter(grp != "B") %>%
  filter(LengthMM > 0) %>%
  ggplot(aes(x = grp, y = LengthMM, color = grp)) +
  geom_violin() +
  facet_grid(cols = vars(B), scales = "free") +
  theme_bw() +
  labs(x = "Sebastes alutus, genetic group",
       y = "Length (mm)",
       title = "Sebastes alutus, length by genetic group") +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  ) +
    scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "firebrick", "darkorange"))

# violin plot with dot plot

l + geom_boxplot(width=0.1, color = "black") +
  geom_jitter(shape=16, position=position_jitter(0.1), alpha = 0.6)


ggsave("pdf_outputs/pop_grp_length_dist.pdf")

```

NOTE: I need to think critically about whether a cohort effect could cause the pop structure that we're seeing... my gut reaction is no, but then again, these are long-lived highly fecund marine species.



# GTseq ascertainment panel from lcWGS


Laura gave me the file that included the samples that were used to identify group membership for GTseq design (assuming admixed individuals were not used, but we can verify that later).


```{r inds-for-panel-design}
gtseq_panel_pops <- read_xlsx("../data/pop_167_grps_used_for_GTseq_design.xlsx") %>%
  mutate(ABLG = str_replace(ABLG, "ABLG", ""))

gtseq_panel_pops$ABLG <- as.numeric(gtseq_panel_pops$ABLG)

```
I removed duplicates earlier in the workflow.



```{r inds-for-panel-design-plot}
gtseq_panel_ind_long_df <- gtseq_panel_pops %>%
  inner_join(., long_df_w_grps, by = c("ABLG" = "INDIVIDUALS")) %>%
  select(-STRATA) %>%
  rename(INDIVIDUALS = ABLG, STRATA = pop_assign)

# convert_to_genind_pca(gtseq_panel_ind_long_df, "gtseq_panel_design_indivs_NEW_mergedVCF")

```
Better, but not 100% assignment with those individuals. I think admixture might be the next step?


For those individuals that are clustering with the wrong group, do they have high amounts of missing data, or other potential explanations?

Because I want to play with this more, I'll import the function for the PCA here and break it down:
```{r ascertainment-samples}
long_df_strata <- gtseq_panel_ind_long_df
  
      # reformat genotypes for genind conversion
      # create 3 digit integers from the genotypes
      long_df_strata$GT3 <- Format(long_df_strata$GT, ldigits = 3, digits = 0)
      
      # fix NAs
      long_df0s <- long_df_strata %>%
        mutate(GT3 = ifelse(is.na(GT3), "000", GT3))
      
      # Now combine the GT3 column per indiv/marker:
      # make the genos characters and then try pasting them as strings
      long_df0s$GT3 <- as.character(long_df0s$GT3)
      
      long_df3digit <- long_df0s %>%
        group_by(INDIVIDUALS, MARKERS) %>% 
        arrange(GT3, .by_group = TRUE) %>% 
        summarise(GENOTYPE = toString(GT3))
      
      # paste strings together
      long_df3digit$GENOTYPE <- gsub(", ","",long_df3digit$GENOTYPE)
      
      # add back on species identity as strata
      df_for_conversion <- long_df0s %>% 
        select(-GT, -GT3) %>%
        left_join(., long_df3digit) %>%
        unique() %>%
        rename(GT = GENOTYPE) %>%
        mutate(GT = ifelse(GT == "000000", NA, GT))
      
      df_for_conversion$STRATA <- as.factor(df_for_conversion$STRATA)
      
      # use the radiator package for this conversion
      genind_df <- write_genind(df_for_conversion)
      
      
      # Now that the data is a genind object, we can do all sorts of things using the adegenet package.
      # Make PCA
      
      # Allele presence absence data are extracted and NAs replaced using tab:
      datasetX <- tab(genind_df, freq = FALSE, NA.method="asis") # double check that is this the appropriate method. This didn't seem to make a difference between using T/F and "mean" or "asis"
      
      # make PCA
      dataset_pca1 <- dudi.pca(datasetX, center = TRUE, scale=FALSE, scannf = FALSE, nf = 6) # I lowered this based on the screeplot
      
      dataset_pca1$li # these are the principal components of the analysis; these are the synthetic variables summarizing the genetic diversity, usually visualized using scatterplots.
      
      dataset_pca1$c1 # these are the allele loadings, used to compute linear combinations forming the PCs; squared, they represent the contribution to each PCs.

#s.label(dataset_pca1$li)
      
# PC axes 1 and 2    
# s.class(dataset_pca1$li, fac=pop(genind_df),
# col=transp(funky(6),.7),
# axesel=T, cstar=0, cpoint=1)
#add.scatter.eig(dataset_pca1$eig[1:50],3,1,2, ratio=.3)

# PC axes 2 and 3
# s.class(dataset_pca1$li, fac=pop(genind_df),
#         xax=2, yax=3,
#         col=transp(funky(6),.9),
#         axesel=FALSE, cstar=0, cpoint=1)
# add.scatter.eig(dataset_pca1$eig[1:50],3,2,3, ratio=.3)
#       
# 
# dataset_pca1$eig[4]
# pc1 <- dataset_pca1$li[,1]
# var(pc1)
# 
# eig.perc <- 100*dataset_pca1$eig/sum(dataset_pca1$eig)
# head(eig.perc)
# 

## allele contributions
# loadingplot(dataset_pca1$c1^2, cex.lab = 0.5, lab.jitter = 1)
# 
# 
# loadingplot(dataset_pca1$c1^2, threshold = 0.0085)
# 
# # which alleles are driving the patterns?
# imp_alleles <- rownames_to_column(dataset_pca1$c1^2, var = "locus") %>%
#   filter(CS1 > 0.007)
# 
# imp_alleles %>%
#   tidyr::separate_wider_delim(locus, ".", names = c("chr", "allele"))
```


```{r create-pca-output-more-usable}
pca_df <- rownames_to_column(dataset_pca1$li, var = "indiv")

# Calculate proportion of total variance
eig.perc <- 100*dataset_pca1$eig/sum(dataset_pca1$eig)
head(eig.perc)



as.tibble(genind_df@strata) %>%
  left_join(., pca_df, by = c("INDIVIDUALS" = "indiv")) %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis1, y = Axis2, label = INDIVIDUALS, color = STRATA)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_text(nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq ascertainment samples",
       x = "PC1, 41.3%",
       y = "PC2, 11.3%",
       color = "Genetic group \n (lcWGS data)") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue")) +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )
  
ggsave("pdf_outputs/gtseq_ascertainment_samples_strata_pca_PC1_PC2.pdf", width = 8, height = 6)


as.tibble(genind_df@strata) %>%
  left_join(., pca_df, by = c("INDIVIDUALS" = "indiv")) %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis2, y = Axis3, label = INDIVIDUALS, color = STRATA)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_text(nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq ascertainment samples",
       x = "PC2, 11.3%",
       y = "PC3, 3.8%",
       color = "Genetic group \n (lcWGS data)") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue")) +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )
  
ggsave("pdf_outputs/gtseq_ascertainment_samples_strata_pca_PC2_PC3.pdf", width = 8, height = 6)
```



Samples that fall outside their target groups:

748
710
661
693
781
780
722
762
663
775
721
783
738

Next steps: remove these samples from the "baseline." Look at HWE, admixture, etc.


Look at A vs. D without B present:

```{r pca-without-B}
ascer_AandD <- gtseq_panel_ind_long_df %>%
  filter(STRATA %in% c("A", "C", "D"))
  
 # reformat genotypes for genind conversion
# create 3 digit integers from the genotypes
ascer_AandD$GT3 <- Format(ascer_AandD$GT, ldigits = 3, digits = 0)
      
# fix NAs
ascer_AandD <- ascer_AandD %>%
  mutate(GT3 = ifelse(is.na(GT3), "000", GT3))
      
# Now combine the GT3 column per indiv/marker:
# make the genos characters and then try pasting them as strings
ascer_AandD$GT3 <- as.character(ascer_AandD$GT3)
      
ascer_3digit <- ascer_AandD %>%
    group_by(INDIVIDUALS, MARKERS) %>% 
    arrange(GT3, .by_group = TRUE) %>% 
    summarise(GENOTYPE = toString(GT3))
      
# paste strings together
ascer_3digit$GENOTYPE <- gsub(", ","",ascer_3digit$GENOTYPE)
      
# add back on species identity as strata
ascer_for_conversion <- ascer_AandD %>% 
        select(-GT, -GT3, -MARKERS) %>%
        left_join(., ascer_3digit) %>%
        unique() %>%
        rename(GT = GENOTYPE) %>%
        mutate(GT = ifelse(GT == "000000", NA, GT))
      
ascer_for_conversion$STRATA <- as.factor(ascer_for_conversion$STRATA)
      
# use the radiator package for this conversion
ascer_genind <- write_genind(ascer_for_conversion)
      
# Allele presence absence data are extracted and NAs replaced using tab:
ascer_data_pca <- tab(ascer_genind, freq = FALSE, NA.method="asis") # double check that is this the appropriate method. This didn't seem to make a difference between using T/F and "mean" or "asis"
      
# make PCA
ascer_pca <- dudi.pca(ascer_data_pca, center = TRUE, scale=FALSE, scannf = FALSE, nf = 6) # I lowered this based on the screeplot
      
AandD_df <- rownames_to_column(ascer_pca$li, var = "indiv")

# plot PCA axes 1 and 2
as.tibble(ascer_genind@strata) %>%
  left_join(., AandD_df, by = c("INDIVIDUALS" = "indiv")) %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis1, y = Axis2)) +
  geom_point(aes(color = STRATA), size = 3, alpha = 0.5) +
  geom_text(aes(label = INDIVIDUALS, color = STRATA), nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq ascertainment samples \n groups A and D; PC1, PC2",
       x = "PC1, 21.4%",
       y = "PC2, 11.6%",
       color = "Genetic group \n (lcWGS data)") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue")) +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )
  
ggsave("pdf_outputs/ascertainment_A_and_D_grps_PC1_PC2.pdf", width = 8, height = 6)



# plot Axes 2 and 3
as.tibble(ascer_genind@strata) %>%
  left_join(., AandD_df, by = c("INDIVIDUALS" = "indiv")) %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis2, y = Axis3)) +
  geom_point(aes(color = STRATA), size = 3, alpha = 0.5) +
  geom_text(aes(label = INDIVIDUALS, color = STRATA), nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq ascertainment samples \n groups A and D; PC2, PC3",
       x = "PC2, 11.6%",
       y = "PC3, 6.1%",
       color = "Genetic group \n (lcWGS data)") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue")) +
   theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )
  
ggsave("pdf_outputs/ascertainment_A_and_D_grps_PC2_PC3.pdf",  width = 8, height = 6)

```
How much variation is explained by PC1 and PC2 in that case?

Eigenvalues correspond to absolute variances. However, we sometimes
want to express these values as percentages of the total variation in the data.

```{r}
# Calculate proportion of total variance
ascer_eig.perc <- 100*ascer_pca$eig/sum(ascer_pca$eig)
head(ascer_eig.perc)
```









## Use adegenet for some classic pop gen to go back and check on loci

Check out the ascertainment data first:

```{r using-the-genind-obj-from-above}
tmp <- summary(genind_df)


plot(tmp$Hexp, tmp$Hobs, pch=20, cex=3, xlim=c(.4,1), ylim=c(.4,1))
abline(0,1,lty=2)

```
Heterozygosity deficit likely due to population structure.




## Admixture results from lcWGS data

Analyses output from Laura Timm. 


```{r read-in-multiple-sheets-admixture-from-lcWGS}
path <- "../data/SALU-SSCH_admix_k2-k9.xlsx"
admix <- path %>%
  excel_sheets() %>%
  set_names() %>% 
  map_df(~ read_excel(path = path, sheet = .x), .id = "sheet")
print(admix, n = Inf)

# pivot that to long-format
admix_df <- admix %>%
  mutate(ABLG = str_replace(ABLG, "ABLG", "")) %>%
  pivot_longer(4:12, names_to = "group", values_to = "proportion") %>%
  filter(!is.na(proportion)) 

# plot all lcWGS data
admix_df %>%
    #filter(pop_assign %in% c("B2")) %>%
  ggplot(aes(x = ABLG, y = proportion, fill = group)) +
  geom_bar(stat = "identity") +
    facet_grid(rows = vars(sheet), cols = vars(pop_assign), scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, size = 6, vjust = 0.5, hjust = 0.95),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
    ) +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "midnightblue", "sienna", "slateblue", "darkorange", "purple4", "firebrick")) +
  labs(title = "Sebastes alutus lcWGS samples",
       x = "ABLG sample",
       y = "Proportion")

#ggsave("pdf_outputs/admix_grps_B2.pdf", width = 10, height = 6)
  


ggsave("pdf_outputs/lcwgs_admixture.pdf", width = 12, height = 8)

admix_df %>%
  filter(pop_assign %in% c("A", "B")) %>%
  ggplot(aes(x = ABLG, y = proportion, fill = group)) +
  geom_bar(stat = "identity") +
    facet_grid(rows = vars(sheet), cols = vars(pop_assign), scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, size = 6, vjust = 0.5, hjust = 0.95),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
    ) +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "midnightblue", "sienna", "slateblue", "darkorange", "purple4", "firebrick")) +
  labs(title = "Sebastes alutus lcWGS samples",
       x = "ABLG sample",
       y = "Proportion")
  
ggsave("pdf_outputs/admix_grps_A_B.pdf", width = 10, height = 6)
```



```{r subset-to-the-ascertainment-samples}
gtseq_panel_pops$ABLG <- as.character(gtseq_panel_pops$ABLG)

admix_df %>%
  inner_join(., gtseq_panel_pops, by = "ABLG") %>%
  rename(pop_assign = pop_assign.x) %>%
   ggplot(aes(x = ABLG, y = proportion, fill = group)) +
  geom_bar(stat = "identity") +
    facet_grid(rows = vars(sheet), cols = vars(pop_assign), scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, size = 6, vjust = 0.5, hjust = 0.95),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
    ) +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "midnightblue", "sienna", "slateblue", "darkorange", "purple4", "firebrick")) +
  labs(title = "Sebastes alutus lcWGS GTseq ascertainment samples",
       x = "ABLG sample",
       y = "Proportion")
  

ggsave("pdf_outputs/lcwgs_admixture_gtseq_ascertainment_samples.pdf", width = 12, height = 8)

```

Seems like this is made challenging by the different levels of differentiation among the groups. Performing admixture again on different subsets could be informative.

Ok, so the admixed samples that should not have been included in the ascertainment panel are the following:

661
693
3186
722


Additionally, we can use the admixture analysis (from the lcWGS data) to remove additional samples that were assigned to wrong group for the remaining 168 lcWGS samples that were not used for ascertainment and can contribute to the baseline.
```{r lcWGS-non-ascertainment-samples-for-baseline}

# COME BACK TO THIS.

```



## Looking at non-baseline samples


This is maybe a touch premature because I haven't sorted out the GTseq ascertainment and baseline samples yet, but I do want to take a quick peek at the mixture samples, at least in PCA form.

Go ahead and remove the individuals that are clearly weirdos from the lcWGS admixture data:

```{r remove-admixed-indivs}
admixed_to_remove <- read_csv("../data/lcwgs_samples_to_remove_admixed.csv")

admixed_to_remove$ABLG <- as.character(admixed_to_remove$ABLG) 

# df with the ascertainment ids to retain
admix_df %>%
  inner_join(., gtseq_panel_pops, by = "ABLG") %>%
  rename(pop_assign = pop_assign.x)
```
Take a quick look at the ascertainment admixture plot without the admixed samples:
```{r ascertainment-admixture-weirdos-removed}
ascertain_admix_no_weirdos <- admix_df %>%
  inner_join(., gtseq_panel_pops, by = "ABLG") %>%
  rename(pop_assign = pop_assign.x) %>%
  anti_join(., admixed_to_remove) %>%
   mutate(B = ifelse(pop_assign %in% c("B1", "B2", "B3", "B4"), "B groups", "A, C, D groups")) %>%
  filter(sheet %in% c("k=2", "k=3", "k=4", "k=5", "k=6", "k=7"))

# get the ids and populations for those
clean_ascertain_ids <- ascertain_admix_no_weirdos %>%
  select(ABLG, pop_assign) %>%
  unique()

b_grp_plot <- ascertain_admix_no_weirdos %>%
  filter(B == "B groups") %>%
  inner_join(., gtseq_panel_pops, by = "ABLG") %>%
  rename(pop_assign = pop_assign.x) %>%
   ggplot(aes(x = ABLG, y = proportion, fill = group)) +
  geom_bar(stat = "identity") +
    facet_grid(rows = vars(sheet), cols = vars(pop_assign), scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, size = 6, vjust = 0.5, hjust = 0.95),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
    ) +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "midnightblue", "sienna", "slateblue", "darkorange", "purple4", "firebrick")) +
  labs(title = "\n \n B groups",
       x = "ABLG sample",
       y = "")
  

a_grp_plot <- ascertain_admix_no_weirdos %>%
  filter(B == "A, C, D groups") %>%
  inner_join(., gtseq_panel_pops, by = "ABLG") %>%
  rename(pop_assign = pop_assign.x) %>%
   ggplot(aes(x = ABLG, y = proportion, fill = group)) +
  geom_bar(stat = "identity") +
    facet_grid(rows = vars(sheet), cols = vars(pop_assign), scales = "free_x", space = "free") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, size = 6, vjust = 0.5, hjust = 0.95),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "none"
    ) +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "midnightblue", "sienna", "slateblue", "darkorange", "purple4", "firebrick")) +
  labs(title = "Sebastes alutus lcWGS admixture \n GTseq ascertainment samples \n A, C, D groups",
       x = "ABLG sample",
       y = "Proportion")

cowplot::plot_grid(a_grp_plot, b_grp_plot)

```

Assuming my hypothesis about admixture is correct, let's set up the analysis for performing GSI with the existing 7 groups (and then maybe scale that down later).



Look at mixture samples:
```{r mixture-samples-PCA}
admixed_to_remove$ABLG <- as.numeric(admixed_to_remove$ABLG)

mix_grps_for_pca <- long_df_w_grps %>%
  anti_join(., admixed_to_remove, by = c("INDIVIDUALS" = "ABLG")) %>%
  mutate(STRATA = ifelse(str_detect(STRATA, "B"), "B", STRATA))

```



# Rubias and GSI 


```{r baseline-samples-for-rubias}
alle_idxs$ABLG <- as.character(alle_idxs$ABLG)
# beginning with the alleles for the full dataset
# format for rubias
reference <- alle_idxs %>%
  inner_join(., clean_ascertain_ids) %>% # just the ascertainment samples
  mutate(pop_assign = ifelse(str_detect(pop_assign, "B"), "B", pop_assign)) %>% # pretty sure these are admixed populations of B1 and B4
  select(-allele) %>%
  select(pop_assign, ABLG, everything()) %>%
  rename(collection = pop_assign, indiv = ABLG)

# reference <- alle_idxs %>%
#   inner_join(., clean_ascertain_ids) %>% # just the ascertainment samples
#   filter(!pop_assign %in% c("B2", "B3")) %>% # pretty sure these are admixed populations of B1 and B4
#   select(-allele) %>%
#   select(pop_assign, ABLG, everything()) %>%
#   rename(collection = pop_assign, indiv = ABLG)
  

# make two-col format
ref_two_col <- reference %>%
  unite("loc", 3:4, sep = ".") %>%
  pivot_wider(names_from = loc, values_from = alleidx) %>%
  mutate(repunit = collection) %>%
  mutate(sample_type = "reference") %>%
  select(sample_type, repunit, collection, everything())
```


```{r loo-output, eval=TRUE}
loo_output <- rubias::assess_reference_loo(ref_two_col, gen_start_col = 5, return_indiv_posteriors = T, resampling_unit = "individual", mixsize = 100)

```


```{r plot-results-from-LOO}

pop_loo_summary <- loo_output$mixing_proportions %>%
  group_by(iter, repunit) %>%
  summarise(true_repprop = sum(true_pi), 
            reprop_posterior_mean = sum(post_mean_pi),
            repu_n = sum(n)) %>%
  mutate(repu_n_prop = repu_n / sum(repu_n))%>%
  mutate(Diff = reprop_posterior_mean - repu_n_prop)

ggplot(pop_loo_summary, aes(x = repu_n_prop, # Prop of ind. actually simulated 
                     y = reprop_posterior_mean, #inferred proportion
                     colour = repunit)) +
  geom_point(alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0.1, slope = 1,lty=2, color = "darkgray")+
  geom_abline(intercept = -0.1, slope = 1,lty=2, color = "darkgray")+
  facet_grid(cols = vars(repunit)) +
  labs(y = "Inferred Proporiton",
       x = "True Proportion",
       color = "Reporting group")+
  theme_bw() +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text = element_text(size = 7)
  ) + scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue"))

ggsave("pdf_outputs/loo_test_four_groups.pdf", width = 7, height = 3)
```
A few notes here: at high proportions of group C, we begin underestimating (probably because we have a relatively small sample size for C in the ascertainment panel).



```{r self-assignment-for-z-score-distributions}
# need population specific z-score distributions
selfassigned <- rubias::self_assign(ref_two_col, gen_start_col = 5)

selfassigned %>%
  group_by(indiv) %>%
  slice_max(., order_by = scaled_likelihood) %>%
  ggplot(aes(x = z_score)) +
  geom_histogram() +
  facet_grid(rows = vars(repunit))
  
```
Based on these z-scores, I think there's support for making B1 and B4 separate groups. But, probably need to look more closely with the additional baseline samples.



## Mixture assignment

```{r make-alleles-df}
# format for rubias
mix_idx <- alle_idxs %>%
  anti_join(., clean_ascertain_ids) %>%
  select(-allele) %>%
  mutate(collection = "catch") %>%
  rename(indiv = ABLG) %>%
  unique()

# confirming no duplicates that would prevent rubias from working
# mix_idx %>%
#   unite("loc", 2:3, sep = ".") %>%
#   dplyr::group_by(indiv, collection, loc) %>%
#     dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
#     dplyr::filter(n > 1L)

```


```{r create-two-column-format-for-rubias}
# make two-col format
mix_two_col <- mix_idx %>%
  arrange(indiv, locus, gene_copy) %>%
  unite("loc", 2:3, sep = ".") %>%
  pivot_wider(names_from = loc, values_from = alleidx) %>%
  mutate(repunit = NA) %>%
  mutate(sample_type = "mixture") %>%
  select(sample_type, repunit, collection, everything()) %>%
  ungroup()

# formatting for compatibility
tmp_combo <- bind_rows(ref_two_col, mix_two_col)

mix <- tmp_combo %>%
  filter(sample_type == "mixture")

ref <- tmp_combo %>%
  filter(sample_type == "reference")

```


```{r perform-mixture-assignment-rubias}
# mixture analysis
mixture_assign <- rubias::infer_mixture(reference = ref, mixture = mix, gen_start_col = 5)

```

```{r rubias-output-for-mixture}
indiv_assignments <- mixture_assign$indiv_posteriors %>%
  group_by(indiv) %>%
  slice_max(PofZ)

# assignments at < 90%
indiv_assignments %>%
  filter(PofZ < 0.9)

# check z-scores
indiv_assignments %>%
  arrange(z_score) %>%
  filter(z_score < -3 | z_score > 3)
```
Based on the baseline samples z-scores, I'm fine including all of the samples/assignments 3<4. However, the low ones are strange and worth taking another look.

```{r}
indiv_assignments %>%
  arrange(z_score) %>%
  filter(z_score < -3)
```
Something funky with 
661
693
18470
18478
18450
9163


```{r}
# meta data for those?
outl <- POP_meta_ss %>%
  filter(Sample_ID %in% c("18470", "18478", "18450"))
```

```{r map-the-outliers}
goa_map +
  geom_point(data = outl, aes(x = StartLongitudeDD, y = StartLatitudeDD))

```





### PCA for mixed samples

```{r evaluate-mixed-samples}
pca_df_no_admixed <- long_df_w_grps %>%
  anti_join(., admixed_to_remove, by = c("INDIVIDUALS" = "ABLG"))

# reformat genotypes for genind conversion
# create 3 digit integers from the genotypes
pca_df_no_admixed$GT3 <- Format(pca_df_no_admixed$GT, ldigits = 3, digits = 0)

# fix NAs
pca_df_no_admixed <- pca_df_no_admixed %>%
  mutate(GT3 = ifelse(is.na(GT3), "000", GT3))

# Now combine the GT3 column per indiv/marker:
# make the genos characters and then try pasting them as strings
pca_df_no_admixed$GT3 <- as.character(pca_df_no_admixed$GT3)

pca_no_admixed_3digit <- pca_df_no_admixed %>%
    group_by(INDIVIDUALS, MARKERS) %>%
    arrange(GT3, .by_group = TRUE) %>%
    summarise(GENOTYPE = toString(GT3)) %>%
  ungroup()

# paste strings together
pca_no_admixed_3digit$GENOTYPE <- gsub(", ","",pca_no_admixed_3digit$GENOTYPE)

# add back on species identity as strata
strata <- pca_df_no_admixed %>%
        select(-GT, -GT3, -MARKERS) %>%
  unique()

pca_df_for_conversion <- pca_no_admixed_3digit %>%
        left_join(., strata) %>%
        rename(GT = GENOTYPE) %>%
        mutate(GT = ifelse(GT == "000000", NA, GT)) %>%
  select(INDIVIDUALS, STRATA, MARKERS, GT)

pca_df_for_conversion$STRATA <- as.factor(pca_df_for_conversion$STRATA)

# use the radiator package for this conversion
pca_admix_genind <- write_genind(pca_df_for_conversion)

# Allele presence absence data are extracted and NAs replaced using tab:
admix_data_pca <- tab(pca_admix_genind, freq = FALSE, NA.method="asis") # double check that is this the appropriate method. This didn't seem to make a difference between using T/F and "mean" or "asis"

# make PCA
admix_pca <- dudi.pca(admix_data_pca, center = T, scannf = F, nf = 6) # I lowered this based on the screeplot

no_admix_df <- rownames_to_column(admix_pca$li, var = "indiv") # why is there only one Axis?

# plot PCA axes 1 and 2
as.tibble(pca_admix_genind@strata) %>%
  left_join(., no_admix_df, by = c("INDIVIDUALS" = "indiv")) %>%
  #filter(STRATA != "POP") %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis1, y = Axis2)) +
  geom_point(aes(color = STRATA), size = 2, alpha = 0.3) +
  geom_text(aes(label = INDIVIDUALS, color = STRATA), nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq \n PC1, PC2",
       x = "PC1",
       y = "PC2",
       color = "Genetic group \n (lcWGS data)") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange", "darkgray")) +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )

ggsave("pdf_outputs/mixture_samples_w_gtseq_grps_PC1_PC2.pdf", width = 8, height = 6)

```

From there, we could use the rubias results to take a quick look at the B groups separately from the A,C,D groups to see if we have more resolution in this GTseq panel.

Three samples have a PofZ < 0.9. 
```{r pca-mixture-samples-just-b-groups}
rubias_ind_assign <- indiv_assignments %>%
  filter(PofZ > 0.9) %>% # remove the samples that have a low PofZ
  filter(z_score > -3) %>%
  select(indiv, repunit)


pca_df_for_conversion$INDIVIDUALS <- as.character(pca_df_for_conversion$INDIVIDUALS)
# add the rubias assignments on
mix_df_for_genind_w_assignments <- pca_df_for_conversion %>%
  left_join(., rubias_ind_assign, by = c("INDIVIDUALS" = "indiv")) %>% 
  filter(!is.na(repunit)) %>%
  mutate(STRATA = repunit) %>%
  #filter(STRATA != "POP") %>%
  select(-repunit)

mix_df_for_genind_w_assignments$STRATA <- as.factor(mix_df_for_genind_w_assignments$STRATA)

# use the radiator package to convert to a genind object
pca_admix_genind_assigned <- write_genind(mix_df_for_genind_w_assignments)

# Allele presence absence data are extracted and NAs replaced using tab:
admix_data_pca_rubias <- tab(pca_admix_genind_assigned, freq = FALSE, NA.method="asis") # double check that is this the appropriate method. This didn't seem to make a difference between using T/F and "mean" or "asis"

# make PCA
admix_pca_rubias <- dudi.pca(admix_data_pca_rubias, center = T, scannf = F, nf = 6) # I lowered this based on the screeplot

no_admix_df_rubias <- rownames_to_column(admix_pca_rubias$li, var = "indiv") # why is there only one Axis?

# plot PCA axes 1 and 2
as.tibble(pca_admix_genind_assigned@strata) %>%
  left_join(., no_admix_df_rubias, by = c("INDIVIDUALS" = "indiv")) %>%
  #filter(STRATA != "POP") %>%
 # filter(STRATA %in% c("D", "C")) %>%
  ggplot(aes(x = Axis1, y = Axis2)) +
  geom_point(aes(color = STRATA), size = 2, alpha = 0.3) +
  geom_text(aes(label = INDIVIDUALS, color = STRATA), nudge_x = 0.1, nudge_y = 0.1, size = 2) +
  theme_bw() +
  labs(title = "Sebastes alutus GTseq \n PC1, PC2",
       x = "PC1",
       y = "PC2",
       color = "Genetic group \n (lcWGS data)") +
  #scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange", "darkgray")) +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )


```


# Metadata

How much metadata do we have for the mixture samples and can we use those rubias assignments to boost our sample sizes for looking at depth distribution between the A and D groups, for example?



```{r metadata-for-mixture-samples}
POP_meta_ss$Sample_ID <- as.character(POP_meta_ss$Sample_ID)
mix_assign_w_meta <- indiv_assignments %>%
  filter(PofZ > 0.9) %>% # only three individuals with < 90% assignment probability.
  filter(z_score > -3) %>% # funky low z-scores should be removed
  select(indiv, collection) %>%
  left_join(., POP_meta_ss, by = c("indiv" = "Sample_ID"))

# map those assignments to verify they fit the adult ascertainment sample distributions
goa_map +
  geom_jitter(data = mix_assign_w_meta, aes(x = StartLongitudeDD,y = StartLatitudeDD, color = collection), size = 2, alpha = 0.7, height = 0.2, width = 0.2) +
  facet_wrap(~collection) +
  labs(x = "Longitude",
       y = "Latitude",
       title = "Sebastes alutus rubias group assignments from GTseq panel") +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange","firebrick", "purple4")) +
  theme(
    axis.text = element_text(size = 8),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )
  
ggsave("pdf_outputs/GTseq_sample_distribution.pdf", width = 6, height = 6)
```

So far so good. What about missing metadata for those samples?
```{r}
# lat/lon is present for all but one sample. That's great.
mix_assign_w_meta %>%
  filter(is.na(DepthM)) %>%
  ungroup() %>%
  group_by(CollectionYear, StartLatitudeDD, StartLongitudeDD, HaulID, StationID, DonatingLab) %>%
  tally()

# missing depth for most of the samples. Can we track it down from the Haul/StationID?


```
These are the remaining hauls for which I wasn't able to find Depth metadata - either on the hard copy metadata that Tony provided or in the RACE/GAP AFSC database for bottom trawl.

What about for the samples for which I have depth data?

Read in additional metadata from bottom trawl surveys
```{r bottom-trawl-metadata}
# # I exported this from the very helpful fisheries one-stop shop online
# bt_meta <- read_csv("../data/FOSS_bottomTrawl_haulData.csv")
# POP_meta_ss$CollectionYear <- as.numeric(POP_meta_ss$CollectionYear)
# POP_meta_ss$HaulID <- as.numeric(POP_meta_ss$HaulID)
# 
# bt_meta_for_genos <- POP_meta_ss %>%
#   inner_join(., bt_meta, by = c("CollectionYear" = "Year", "HaulID" = "Haul", "StationID" = "Station"))
# 
# bt_meta_for_genos
# 
# mix_assign_w_meta$HaulID <- as.numeric(mix_assign_w_meta$HaulID)
# 
# pop_mix_assigned_meta <- mix_assign_w_meta %>%
#   left_join(., bt_meta_for_genos) %>%
#   mutate(DepthM = ifelse(!is.na(`Depth M`), `Depth M`, DepthM))
# 
# # how many samples with depth info now?
# mix_assign_w_meta %>%
#   filter(!is.na(DepthM)) %>%
#   filter(DonatingLab == "Tony Gharrett" & DepthM == 0) %>% # can I find more metadata for these based on lat/lon or cruise and haul?
#   left_join(., bt_meta, by = c("CruiseID" = "Cruise", "HaulID" = "Haul"))
# 

```



```{r plot-depths-for-mixture-assignments}
p1 <- mix_assign_w_meta %>%
  group_by(collection) %>%
  filter(!is.na(DepthM)) %>%
  filter(DepthM != 0) %>%
    #filter(LengthMM > 220) %>% # this is the 50% age at maturity, according to Love et al. Mostly, LengthMM is NA
  ggplot(aes(x = collection, y = DepthM, color = collection)) +
  geom_violin() +
  #facet_grid(cols = vars(B), scales = "free") +
  theme_bw() +
  labs(x = "Sebastes alutus, genetic group",
       y = "Depth (m)",
       title = "Sebastes alutus, collection depth by genetic group (rubias assignments)") +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  ) +
    scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "firebrick", "darkorange"))

# violin plot with dot plot
p1 + geom_boxplot(width=0.1, color = "black") +
  geom_jitter(shape=16, position=position_jitter(0.1), alpha = 0.6)

ggsave("pdf_outputs/pop_grp_depth_dist_rubias_assignments.pdf")

```
Average depths for A vs. D?
```{r average-depths-by-group}
mix_assign_w_meta %>%
  group_by(collection) %>%
  filter(!is.na(DepthM)) %>%
  filter(DepthM != 0) %>%
  summarise(mean_depth = mean(DepthM))

# How many samples per?
mix_assign_w_meta %>%
  group_by(collection) %>%
  tally()
  
```


### Mixtures by haul



```{r haul-proportions}
bt_meta <- read_csv("../data/HAUL_DATA.csv")

hauls <- mix_assign_w_meta %>%
  left_join(., POP_meta_ss) %>%
  group_by(HaulID, StationID, StartLatitudeDD, StartLongitudeDD, DonatingLab, CollectionYear, CollectionMonth, CollectionDay) %>%
  tally() %>%
  arrange(n) %>%
  filter(n > 10) %>%
  unite(CollectionYear, CollectionMonth, CollectionDay, col = "SampleDate", sep = "_", remove = F) %>%
  group_by(HaulID, StationID, SampleDate, StartLatitudeDD, StartLongitudeDD) %>%
  rowid_to_column("haul") %>%
  left_join(., mix_assign_w_meta) %>%
  left_join(., bt_meta, by = c("CollectionYear" = "Year", "CruiseID" = "Cruise", "HaulID" = "Haul", "StationID" = "Station")) #%>%
  # mutate(location = ifelse(StartLatitudeDD < 50), "south", NA) %>%
  # mutate(location = ifelse(StartLatitudeDD >))
  
hauls$HaulID <- as.character(hauls$HaulID)
hauls %>%
  filter(!is.na(HaulID)) %>%
   mutate(StartLongitudeDD = ifelse(StartLongitudeDD > 0, StartLongitudeDD*-1, StartLongitudeDD)) %>%
  filter(!StartLongitudeDD == 0) %>%
  ggplot(aes(x = reorder(HaulID, StartLongitudeDD), fill = collection)) +
  geom_bar(stat = "count") +
  theme_bw() +
  scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue", "sienna", "slateblue", "darkorange","firebrick", "purple4")) +
  theme(
    axis.text = element_text(size = 8),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.text.x = element_text(angle = 45)
  ) +
  labs(
    fill = "genetic \n group",
    x = "Haul (ordered by west-to-east by longitude)",
    y = "Number of samples in haul",
    title = "Number of POP per genetic group per haul"
  )

ggsave("pdf_outputs/POP_genetic_group_count_by_haul.pdf", width = 8, height = 6)
```


```{r scatterpie-map}
library(scatterpie)

for_plotting <- hauls %>%
  ungroup() %>%
  select(haul, indiv, StartLatitudeDD, StartLongitudeDD, collection, DepthM, CollectionYear) %>%
  group_by(haul) %>%
  add_tally(name = "n_haul") %>%
  group_by(haul, collection) %>%
  add_tally(name = "n_grp_haul") %>%
  select(-indiv) %>% # summarise over hauls
  unique() %>%
  mutate(grp_prop = n_grp_haul/n_haul) %>%
  select(-n_haul, -n_grp_haul) %>%
  pivot_wider(names_from = collection, values_from = grp_prop) %>%
  group_by(haul) %>%
  replace(is.na(.), 0)

for_plotting$haul <- as.character(for_plotting$haul)

for_plotting$haul <- as.factor(for_plotting$haul)
```


```{r haul-size-by-group}
hauls %>%
  group_by(haul, collection) %>%
  tally() %>%
  group_by(haul) %>%
  mutate(haul_size = sum(n)) %>%
  ungroup() %>% 
  ggplot(aes(x = reorder(haul, haul_size), y = n, fill = collection)) +
  geom_bar(stat = "identity") +
  theme_bw() +
   scale_fill_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue"))
  
# sizes/lengths
# pull info about haul years
hauls %>%
  ungroup() %>%
  group_by(CollectionYear, CruiseID) %>%
  tally() %>%
  arrange(CollectionYear)
```
Even if I can't get individual length data for every fish, I could get length data per haul and then look at the hauls that are >90% one form...




```{r scatterpie-map1}
# map
# goa_map +
#   geom_scatterpie(aes(x = StartLongitudeDD,y = StartLatitudeDD, r = 1),
#                    data = for_plotting, cols = colnames(for_plotting[, c(6:9)]), alpha = 0.6) +
#   scale_fill_manual(values = c("deepskyblue", "salmon", "darkblue", "darkcyan")) +
# theme(
#   axis.text = element_text(size = 8),
#   axis.title.x = element_text(margin = margin(t = 10)),
#   axis.title.y = element_text(margin = margin(r = 10)),
#   legend.title = element_text(size = 8)
# ) +
#   labs(title = "Bottom trawl proportions by genetic group", x = "Longitude", y = "Latitude",
#        fill = "genetic \n group")

```

```{r zoomed-in-map}
goa_map_zoom <- ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-179, -130), 
           ylim = c(62, 50), 
           expand = FALSE) +
  theme_bw()

goa_map_zoom +
  geom_scatterpie(aes(x = StartLongitudeDD,y = StartLatitudeDD, r = 0.5),
                   data = for_plotting, cols = colnames(for_plotting[, c(6:9)]), alpha = 0.5) +
scale_fill_manual(values = c("deepskyblue", "salmon", "darkblue", "darkcyan")) +
  #facet_wrap(~CollectionYear) +
  theme(
  axis.text = element_text(size = 8),
  axis.title.x = element_text(margin = margin(t = 10)),
  axis.title.y = element_text(margin = margin(r = 10)),
  legend.title = element_text(size = 8)
) +
  labs(title = "Bottom trawl proportions by genetic group", x = "Longitude", y = "Latitude",
       fill = "genetic \n group") 

ggsave("pdf_outputs/haul_proportions.pdf", width = 12, height = 7)


```

```{r}
wgoa_west <- ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-179, -140), 
           ylim = c(62, 50), 
           expand = FALSE) +
  theme_bw()

wgoa_west +
  geom_scatterpie(aes(x = StartLongitudeDD,y = StartLatitudeDD, r = 0.5),
                   data = for_plotting, cols = colnames(for_plotting[, c(5:8)]), alpha = 0.5) +
  scale_fill_manual(values = c("deepskyblue", "salmon", "darkblue", "darkcyan")) +
theme(
  axis.text = element_text(size = 8),
  axis.title.x = element_text(margin = margin(t = 10)),
  axis.title.y = element_text(margin = margin(r = 10)),
  legend.title = element_text(size = 8)
) +
  labs(title = "Bottom trawl proportions by genetic group", x = "Longitude", y = "Latitude",
       fill = "genetic \n group")

ggsave("pdf_outputs/pop_proportions_by_haul_west.pdf", width = 8, height = 6)
```

If we think there's depth segregation, we should look at a bathymap.
```{r kodiak-to-aleutians}
wgoa_west <- ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-155, -142), 
           ylim = c(61, 55), 
           expand = FALSE) +
  theme_bw()

wgoa_west +
  geom_scatterpie(aes(x = StartLongitudeDD,y = StartLatitudeDD, r = 0.2),
                   data = for_plotting, cols = colnames(for_plotting[, c(6:9)]), alpha = 0.6) +
scale_fill_manual(values = c("deepskyblue", "salmon", "darkblue", "darkcyan")) +
  theme(
  axis.text = element_text(size = 8),
  axis.title.x = element_text(margin = margin(t = 10)),
  axis.title.y = element_text(margin = margin(r = 10)),
  legend.title = element_text(size = 8)
) +
  labs(title = "Genetic groups by haul near Kodiak/Kenai split", x = "Longitude", y = "Latitude",
       fill = "genetic \n group") 
  

ggsave("pdf_outputs/pop_proportions_by_haul_kodiak.pdf", width = 8, height = 6)

```

### Depth by longitude

```{r analyzing-depth-by-longitude}
mix_assign_w_meta %>%
  mutate(StartLongitudeDD = ifelse(StartLongitudeDD > 0, StartLongitudeDD*-1, StartLongitudeDD)) %>%
  filter(!StartLongitudeDD == 0,
         DepthM != 0) %>%
  ggplot(aes(x = StartLongitudeDD, y = DepthM, color = collection)) +
  geom_jitter(size = 1, alpha = 0.4, width = 1.5, height = 10) +
  scale_color_manual(values = c("darkcyan", "deepskyblue", "salmon", "darkblue")) +
  theme_bw() +
  labs(
    x = "Longitude W",
    y = "Depth (m)",
    color = "genetic \n group",
    title = "Genetic group by longitude and depth"
  ) + annotate("text", x = -178, y = 390, label = "deep") +
  annotate("segment", x = -178, xend = -178, y = 350, yend = 378, color = "black", arrow = arrow(length = unit(0.2, "cm"))) +
  guides(colour = guide_legend(override.aes = list(alpha = 1)))

ggsave("pdf_outputs/genetic_group_ind_longitude_depth.pdf", width = 8, height = 6)
```

```{r with-pies}
plot_pie_data <- for_plotting %>%
   mutate(StartLongitudeDD = ifelse(StartLongitudeDD > 0, StartLongitudeDD*-1, StartLongitudeDD)) %>%
  filter(!StartLongitudeDD == 0,
         DepthM != 0)

ggplot() +
  geom_scatterpie(aes(x = StartLongitudeDD,y = DepthM/-10, r = 1),
                   data = plot_pie_data, cols = colnames(for_plotting[, c(5:8)]), alpha = 0.6) +
  scale_fill_manual(values = c("deepskyblue", "salmon", "darkblue", "darkcyan")) +
  labs(title = "Haul proportions by genetic group, depth, longitude", 
       x = "Longitude", 
       y = "Bottom depth*10 (m)",
       fill = "genetic \n group") +
  theme_bw() +
  theme(
  axis.text = element_text(size = 8),
  axis.title.x = element_text(margin = margin(t = 10)),
  axis.title.y = element_text(margin = margin(r = 10)),
  legend.title = element_text(size = 8)
) +
  annotate("text", x = -178, y = -37, label = "deep") +
  annotate("segment", x = -178, xend = -178, y = -32, yend = -36, color = "black", arrow = arrow(length = unit(0.2, "cm"))) +
  annotate("text", x = -174, y = -38, label = "west") +
  annotate("segment", x = -165, xend = -172, y = -38, yend = -38, color = "black", arrow = arrow(length = unit(0.2, "cm")))


ggsave("pdf_outputs/trawl_proportions_longitude_depth.pdf", width = 7, height = 5)
```





```{r bathymap}
library(marmap)

aleu <- getNOAA.bathy(175, -145, 50, 65, resolution = 5,
antimeridian = TRUE)

goa_bathy <- getNOAA.bathy(175, -130, 45, 65, resolution = 3,
antimeridian = TRUE)

kodiak_bathy <- getNOAA.bathy(-155, -142, 55, 62, resolution = 10)
```

The bathymap and the dataset are in different coordinate systems. Need to covert one to the other for plotting.
Worth exploring some other options too:
https://github.com/DataScienceHobart/2017-02-03-graphics-imas/issues/3
https://mikkovihtakari.github.io/ggOceanMaps/articles/ggOceanMaps.html


```{r}
# get the longitude to line up between the bathy map and the dataset
plot_df <- for_plotting %>%
  mutate(lon = ifelse(StartLongitudeDD < 0, 360+StartLongitudeDD, 360-StartLongitudeDD)) %>%
  mutate(lat = StartLatitudeDD) 

autoplot.bathy(goa_bathy, geom = c("raster", "contour", alpha = 0.5), coast = T) +
  scale_fill_etopo() +
  geom_point(data = plot_df, aes(x = lon, y = lat),
               colour = 'firebrick', size = 2, alpha = 0.9) +
    labs(y = "Latitude", x = "Longitude", fill = "Elevation")

```

From there, I want to remove the detail from the land elevation and provide more detail about the hauls.

```{r marmap-kodiak-area}
dat_for_kodiak <- plot_pie_data %>%
  filter(StartLongitudeDD < -141)

# Creating a custom palette of blues
blues <- c("lightsteelblue4", "lightsteelblue3",
"lightsteelblue2", "lightsteelblue1")

jpeg(filename = "pdf_outputs/kodiak_bathymetry_with_hauls.jpg", width = 8, height = 6, units = "in", res = 600)
# Plotting the bathymetry with different colors for land and sea
plot(kodiak_bathy, image = TRUE, land = TRUE, lwd = 0.1,
bpal = list(c(0, max(kodiak_bathy), "grey"),
c(min(kodiak_bathy),0,blues)))
# Making the coastline more visible
plot(kodiak_bathy, deep = 0, shallow = 0, step = 0,
lwd = 0.4, add = TRUE)
scaleBathy(kodiak_bathy, deg=1, x="bottomright", y = NULL, inset = 12)
# add points
points(dat_for_kodiak$StartLongitudeDD, dat_for_kodiak$StartLatitudeDD, pch = 21, col = "black", bg = "seagreen4", cex = 1.3)
text(-153, 58, "Kodiak Is.", col = "black", font = 3)
text(-150.5, 60, "Kenai Pen.", col = "black", font = 3)
dev.off()
```


```{r bathy-transect}
trsect <- get.transect(kodiak_bathy, -155, 56, -150, 59, distance = T) # get transect near Kodiak
plotProfile(trsect)
```






New mapping approach:

```{r}
library(ggOceanMaps)
library(ggspatial)

```

```{r using-ggOceanMaps}
basemap(limits = c(175, -133, 50, 60), bathymetry = T, rotate = T) +
  ggspatial::geom_spatial_point(data = plot_df, aes(x = lon, y = lat), color = "red")


basemap(limits = c(-155, -148, 50, 60), bathymetry = T, rotate = T) +
  ggspatial::geom_spatial_point(data = plot_df, aes(x = lon, y = lat), color = "red")
```

Zoom in on the central GOA
```{r format-df}
haul_id_df <- hauls %>%
  ungroup() %>%
  select(haul, StartLatitudeDD, StartLongitudeDD, n, collection, DepthM, `Bottom Temperature C`, `Surface Temperature C`) %>%
  rename(lat = StartLatitudeDD) %>%
   mutate(lon = ifelse(StartLongitudeDD < 0, 360+StartLongitudeDD, 360-StartLongitudeDD)) %>%
  group_by(haul, collection) %>%
  add_tally(name = "n_grp_per_haul")
  
```


always new stuff to learn here:
https://r-graph-gallery.com/ggplot2-package.html

```{r central-goa}
central_goa <- basemap(limits = c(-155, -133, 53, 60), bathymetry = T, rotate = T) 

central_goa +
 ggspatial::geom_spatial_point(data = haul_id_df, aes(x = lon, y = lat, color = collection, size = n_grp_per_haul),
                               geom = "jitter", width = 0.2, height = 0.2) +
  scale_color_manual(values = c("darkorange", "firebrick", 
                                "violet", "gold")) +
  guides(color = guide_legend(override.aes = list(fill = NA)), size = guide_legend(override.aes = list(fill = NA))) +
  theme(
    legend.position = "right"
  ) +
  labs(color = "genetic group",
       size = "N per haul",
       title = "Central GOA, Sebastes alutus \ngenetic group assignments from haul data")
    
ggsave("pdf_outputs/centralGOA_haul_data.pdf", width = 8, height = 5)
```

For hauls < a certain depth, we would expect very few A group samples and dominanted by D group samples in the Aleutians/wGOA.

Look more at the A vs. D relationship
```{r aleutians-and-D-vs-A-groups}
aleutians <- basemap(limits = c(175, -150, 50, 60), bathymetry = T, rotate = T) 

aleutians +
 ggspatial::geom_spatial_point(data = haul_id_df, aes(x = lon, y = lat, color = collection, size = n_grp_per_haul)) +
  scale_color_manual(values = c("darkorange", "firebrick", 
                                "violet", "gold")) +
  guides(color = guide_legend(override.aes = list(fill = NA)), size = guide_legend(override.aes = list(fill = NA))) +
  theme(
    legend.position = "right",
    legend.direction = "vertical",
    legend.box = "horizontal"
  ) +
  labs(color = "genetic group",
       size = "N per haul",
       title = "Kodiak - Aleutians, Sebastes alutus \ngenetic group assignments from haul data")
    

ggsave("pdf_outputs/aleutians_haul_data.pdf", width = 10, height = 5)

```

Okay, okay. Enough with the maps for now. Let's look at composition of hauls that are shallower/deeper and how that matches up with presence/proportion of A/D group individuals.


COME BACK AND MAKE FINAL MAPS.
COME BACK AND FINISH EVALUATING THE DIFFERENCE IN DEPTH BETWEEN A & D.



Test for a relationship between depth and proportion of D individuals?
```{r depth-analysis}
haul_id_df %>%
  filter(collection %in% c("A", "D") & DepthM > 0) %>%
  mutate(prop_D_haul = ifelse(collection == "D", n_grp_per_haul/n, NA)) %>%
  mutate(prop_A_haul = ifelse(collection == "A", n_grp_per_haul/n, NA)) %>%
  unique()  %>%
  ggplot() +
  geom_point(aes(x = DepthM, y = prop_D_haul)) +
  theme_bw() +
  labs(x = "Depth (m)",
       y = "Proportion of genetic group D per haul")


```

histograms?
```{r}
haul_id_df %>% filter(DepthM > 0 & StartLongitudeDD < -150) %>%
  #filter(collection %in% c("A", "D") & DepthM > 0) %>%
  mutate(prop_per_haul = n_grp_per_haul/n) %>%
  unique()  %>%
  ggplot() +
  #geom_bar(aes(x = DepthM, y = prop_per_haul, fill = collection), position = position_dodge2(preserve = "single"), stat = "identity", width = 10) +
  geom_bar(aes(x = DepthM, y = prop_per_haul, fill = collection), position = "stack", stat = "identity", width = 10) +
  theme_bw() +
  #facet_grid(rows = vars(collection)) +
  labs(x = "Depth (m)",
       y = "Proportion of genetic group per haul",
       fill = "Genetic group",
       title = "Sebastes alutus depth distribution \nA vs. D groups") +
  theme(
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.title.y = element_text(margin = margin(r = 10))
  )

ggsave("pdf_outputs/depth_dist_A_vs_D_hauls.pdf", height = 4, width = 6)
```


```{r t-test-means-for-A-and-D-groups}
t.test(x = D_haul$DepthM, y = A_haul$DepthM, alternative = c("two.sided"), mu = 47, paired = F)

D_haul <- haul_id_df %>%
   ungroup() %>%
  filter(collection == "D") %>%
  filter(!is.na(DepthM) & DepthM > 0) 

A_haul <- haul_id_df %>%
  ungroup() %>%
  filter(collection == "A") %>%
  filter(!is.na(DepthM) & DepthM > 0)

haul_id_df %>%
  ungroup() %>%
  filter(!is.na(DepthM) & DepthM > 0) %>%
  group_by(collection) %>%
  summarise(mean_depth = mean(DepthM))

242-195

haul_df_for_stats <- haul_id_df %>%
  mutate(prop_in_haul = n_grp_per_haul/n) %>%
  filter(DepthM > 0)
```
sums of squares fct?
explicitly deal with the fact that there are multiple samples from the same haul, random effect?? Not independent

treat haul as the unit/replicate - sampling unit




```{r}
model1 <- glm(haul_df_for_stats$prop_in_haul ~ haul_df_for_stats$collection:haul_df_for_stats$DepthM, family = "binomial") # can use a binomial with proportion according to 


summary(model1)
```


```{r}
haul_df_for_stats %>%
  filter(prop_in_haul > 0.5 & collection %in% c("A", "D")) %>%
  ggplot(aes(x = DepthM, y = prop_in_haul, color = collection)) +
  geom_point() +
  geom_smooth(method = "lm")

```



## Other analyses




```{r genepop-to-check-for-LD}
# library(genepop)
# install.packages("writeGenPop")
# library(writeGenPop)
# 
# # convert genind to genepop format:
# gtseq_ascer_genepop <- genind2genpop(genind_df)
# 
# write_genepop(genind_df, filename = "csv_outputs/pop_gtseq_ascertainment_genepop.txt")
# 
# # Pat wants me to look at LD in my markers.
# ld_test <- genepop::test_LD(gtseq_ascer_genepop)

```

